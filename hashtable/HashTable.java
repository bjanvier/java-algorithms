package hashtable;

/**
 * @author Janvier Zagabe
 * 
 * @HashTable(Hash set and hash map): get the sum of all the characters in a
 *                 string, then divide the sum by the size of the array, the
 *                 new index is the remainder value
 * 
 * 
 */
public class HashTable<T> {
    // private int size = 10;

    public int generateHashCode(Object... obj) {
        String[] hStr = new String[obj.length];
        // o;//.toString().split("");

        int i = 0;
        for (Object o : obj) {
            hStr[i] = (String) o;
            i++;
        }

        int hashCode = 0;
        int count = hStr.length - 1;
        int j = 0;

        while (count > 0) {
            int hc = hStr[j].hashCode();
            hashCode += hc * (int) Math.pow(31, count);
            count--;
            j++;
        }

        // while (count > 0) {
        // int hc = hStr[j].hashCode();
        // hashCode += hc;
        // count--;
        // j++;
        // }
        hashCode += hStr[hStr.length - 1].hashCode();

        return hashCode;
    }

    /**
     * Compressing the hash code to become
     * a real array index
     * 
     * @param o
     * @return
     */
    public int compress(Object o, int size) {
        int h = o.hashCode();
        // System.out.println(o.hashCode());

        if (h < 0) {
            h = -h;
        }
        return h % size;
    }

    /**
     * WHen the compressed index returns an item
     * that's not null, then the linear search should
     * be applied until the the next null/empty spot is
     */
    public Object[] linearProbing(Object[] arr) {
        Object[] newArray = new Object[arr.length];

        for (int i = 0; i < arr.length; i++) {
            int h = compress(arr[i], arr.length);
            System.out.println(h + "\t " + i);
            if (newArray[h] == null) {
                newArray[h] = arr[i];
            } else {
                // Do the linear search to find the next open
                // to handle the collision
                int j = 0;
                while (j <= arr.length - 1) {
                    if (newArray[j] == null) {
                        newArray[j] = arr[i];
                        break;
                    }
                    j++;
                }
            }
        }
        return newArray;
    }

    public void separateChaining(Object[] arr) {

        for (int i = 0; i < arr.length; i++) {
            for (int j = 0; j < arr.length; j++) {
                int bucketSize = 0;
                while (i != j && arr[i].hashCode() == arr[j].hashCode()) {

                    bucketSize++;

                    // TODO: CREATE a bucket that will contain
                    // all colliding elements, assuming that
                    // colliding i and j are both hash codes
                    // and arr as a hash table.
                    Object[] bucket = new Object[bucketSize];

                    bucket[i] = arr[i];
                    bucket[j] = arr[j];

                    // TODO: These two need to be removed before
                    // pushing the bucket at @index generated by hashcode compression
                    // That way we can stop the while loop when there is no
                    // more any match
                    arr[i] = null;
                    arr[j] = null;

                    // todo: push the colliding linked list of items into
                    // Placing the bucket at the end of the array
                    // arr[compress(generateHashCode(arr[i], arr[j]))] = bucket;
                }
            }
        }
    }
}
